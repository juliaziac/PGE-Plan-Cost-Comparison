import pandas as pd
import numpy as np
import re
import datetime

def process_csv(filename: str): # -> tuple[pd.DataFrame, str]:
    """Converts a PGE csv file into a dataframe and its energy type name.

    Args:
        filename (str): The csv file path. Keep the PGE csv naming convention for proper parsing.

    Returns:
        df (pd.DataFrame): A dataframe of energy data. Dates are converted for proper merging with other 
            PGE csv's.
        df_name (str): The energy type ('gas' or 'electric') as designated by PGE's csv naming convention.
    """

    df = pd.read_csv(filename, header=4, parse_dates=['START DATE', 'END DATE'])
    df['MID-DATE'] = df['START DATE'] + datetime.timedelta(days=5) # to accomodate month-end start dates
    df['MONTH'] = df['MID-DATE'].dt.to_period('M')
    df_name = re.search(r'_([^_]*)_', filename).group(1)
    return df, df_name

def combine_and_process(df1: pd.DataFrame, df1_name: str, df2: pd.DataFrame, df2_name: str) -> pd.DataFrame:
    """Combines gas and electric data and computes rolling 12-month cost average.

    Args:
        df1 (pd.DataFrame): Gas or electric data parsed by the function process_csv.
        df1_name (str): The energy type of the first dataframe. This will be used as the suffix
            when the data is combined.
        df2 (pd.DataFrame): The other energy type data parsed by the function process_csv.
        df2_name (str): The energy type of the second dataframe. This will be used as the suffix
            when the data is combined.

    Returns:
        df (pd.DataFrame): A dataframe of the gas and electric data combined, with the rolling 12-month
            cost average computed.
    """

    df = pd.merge(left=df1, right=df2, left_on='MONTH', right_on='MONTH',
                suffixes=[f'_{df1_name}', f'_{df2_name}'])
    df['TOTAL_COST'] = df[f'COST_{df1_name}'].str.slice(start=1).astype(float)\
        + df[f'COST_{df2_name}'].str.slice(start=1).astype(float)
    df.sort_values(by='MONTH', ascending=True)
    df['1Y_ROLLING_AVG'] = df.rolling(12).mean().round(2)['TOTAL_COST']
    return df

def cost_comparison_quarterly_one_year(row_index: int) -> pd.DataFrame:
    """Computes the optimal quarterly PGE plan for a time span of one year.

    Starting after 1 full year of data, compute rolling 12-month average and 
    compare it 4x to the sum of the next 4 months.

    Args:
        row_index (int): The row index of the start month for the desired one year time span.
            The row refers to the dataframe generated by the combine_and_process function.

    Returns:
        df (pd.DataFrame): A 4-row dataframe where each row denotes a quarter of a year,
            showing which PGE plan is cheaper and by what dollar amount.
    """

    df = pd.DataFrame(columns=['start_month', 'end_month', 'cheaper_plan', 'cheaper_by_$'])
    start_row = row_index
    for i in range(4):
        start_month = total.iloc[start_row]['MONTH']
        end_month = total.iloc[start_row+3]['MONTH']
        budget_cost = total.iloc[start_row]['1Y_ROLLING_AVG']*4
        actual_cost = 0
        for i in range(4):
            actual_cost += total.iloc[start_row+i]['TOTAL_COST']
        cost_difference = actual_cost - budget_cost
        if cost_difference > 0:
            cheaper_plan = 'budget cost'
        if cost_difference < 0:
            cheaper_plan = 'actual cost'
            cost_difference *= -1
        if cost_difference == 0:
            cheaper_plan = 'no difference'
        df.loc[len(df.index)] = [start_month, end_month, cheaper_plan, cost_difference]
        start_row += 3
    return df

def cost_comparison_yearly(quarterly_df: pd.DataFrame) -> pd.DataFrame:
    """Computes the optimal yearly PGE plan.

    Args:
        quarterly_df (pd.DataFrame): A 4-row dataframe showing the optimal quarterly plan,
            as generated by the function cost_comparison_quarterly_one_year.

    Returns:
        df (pd.DataFrame): A 1-row dataframe showing the which PGE plan is cheaper for the
            entire year and by what dollar amount.
    """

    df = pd.DataFrame(columns=['start_month', 'end_month', 'cheaper_plan', 'cheaper_by_$'])
    start_month = quarterly_df['start_month'].min()
    end_month = quarterly_df['end_month'].max()
    quarterly_df['cheaper_by_$'].where(quarterly_df['cheaper_plan']=='actual cost',\
                -quarterly_df['cheaper_by_$'], inplace=True)
    cost_difference = quarterly_df['cheaper_by_$'].sum()
    if cost_difference > 0:
        cheaper_plan = 'actual cost'
    if cost_difference < 0:
        cheaper_plan = 'budget cost'
        cost_difference *= -1
    if cost_difference == 0:
        cheaper_plan = 'no difference'
    df.loc[len(df.index)] = [start_month, end_month, cheaper_plan, cost_difference]
    return df

def total_analysis(combined_df: pd.DataFrame) -> pd.DataFrame:
    """Computes the optimal PGE plan and start date for all input data.

    The idea is that if the PGE Budget Billing plan maximized savings for a given year 
    starting in March of that year, for example, then one could assume that it would be
    best to switch to the Budget Billing plan the next possible March.

    Args:
        combined_df (pd.DataFrame): A dataframe of PGE gas and electric data, as parsed by
            the function combine_and_process.

    Returns:
        df (pd.DataFrame): A 1-row dataframe which is the maximum savings possible given
            the input data.
    """

    df = pd.DataFrame(columns=['start_month', 'end_month', 'cheaper_plan', 'cheaper_by_$'])
    start_month_index = np.isnan(combined_df['1Y_ROLLING_AVG']).argmin(axis=0) # first non-null rolling average
    for i in range(start_month_index, len(combined_df.index)-12):
        df = df.append(cost_comparison_yearly(cost_comparison_quarterly_one_year(i)), ignore_index=True)
    return df